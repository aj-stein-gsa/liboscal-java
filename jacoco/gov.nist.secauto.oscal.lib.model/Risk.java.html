<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Risk.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OSCAL Java Library</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.oscal.lib.model</a> &gt; <span class="el_source">Risk.java</span></div><h1>Risk.java</h1><pre class="source lang-java linenums">package gov.nist.secauto.oscal.lib.model;

import gov.nist.secauto.metaschema.core.datatype.adapter.DateTimeWithTZAdapter;
import gov.nist.secauto.metaschema.core.datatype.adapter.IntegerAdapter;
import gov.nist.secauto.metaschema.core.datatype.adapter.TokenAdapter;
import gov.nist.secauto.metaschema.core.datatype.adapter.UuidAdapter;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLineAdapter;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultilineAdapter;
import gov.nist.secauto.metaschema.core.model.IBoundObject;
import gov.nist.secauto.metaschema.core.model.IMetaschemaData;
import gov.nist.secauto.metaschema.core.model.JsonGroupAsBehavior;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraint;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValue;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValues;
import gov.nist.secauto.metaschema.databind.model.annotations.BoundAssembly;
import gov.nist.secauto.metaschema.databind.model.annotations.BoundField;
import gov.nist.secauto.metaschema.databind.model.annotations.BoundFlag;
import gov.nist.secauto.metaschema.databind.model.annotations.GroupAs;
import gov.nist.secauto.metaschema.databind.model.annotations.Matches;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaAssembly;
import gov.nist.secauto.metaschema.databind.model.annotations.ValueConstraints;
import java.lang.Override;
import java.lang.String;
import java.time.ZonedDateTime;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;
import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

/**
 * An identified risk.
 */
@MetaschemaAssembly(
    formalName = &quot;Identified Risk&quot;,
    description = &quot;An identified risk.&quot;,
    name = &quot;risk&quot;,
    moduleClass = OscalAssessmentCommonModule.class,
    valueConstraints = @ValueConstraints(allowedValues = @AllowedValues(level = IConstraint.Level.ERROR, target = &quot;prop[has-oscal-namespace('http://csrc.nist.gov/ns/oscal')]/@name&quot;, values = {@AllowedValue(value = &quot;false-positive&quot;, description = &quot;The risk has been confirmed to be a false positive.&quot;), @AllowedValue(value = &quot;accepted&quot;, description = &quot;The risk has been accepted. No further action will be taken.&quot;), @AllowedValue(value = &quot;risk-adjusted&quot;, description = &quot;The risk has been adjusted.&quot;), @AllowedValue(value = &quot;priority&quot;, description = &quot;A numeric value indicating the sequence in which risks should be addressed. (Lower numbers are higher priority)&quot;)}), matches = @Matches(level = IConstraint.Level.ERROR, target = &quot;prop[has-oscal-namespace('http://csrc.nist.gov/ns/oscal') and @name='priority']/@value&quot;, typeAdapter = IntegerAdapter.class))
)
public class Risk implements IBoundObject {
  private final IMetaschemaData __metaschemaData;

  /**
   * &quot;A &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented\&quot;&gt;machine-oriented&lt;/a&gt;, &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique\&quot;&gt;globally unique&lt;/a&gt; identifier with &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance\&quot;&gt;cross-instance&lt;/a&gt; scope that can be used to reference this risk elsewhere in &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope\&quot;&gt;this or other OSCAL instances&lt;/a&gt;. The locally defined &lt;em&gt;UUID&lt;/em&gt; of the &lt;code&gt;risk&lt;/code&gt; can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency\&quot;&gt;per-subject&lt;/a&gt;, which means it should be consistently used to identify the same subject across revisions of the document.&quot;
   */
  @BoundFlag(
      formalName = &quot;Risk Universally Unique Identifier&quot;,
      description = &quot;A [machine-oriented](https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented), [globally unique](https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique) identifier with [cross-instance](https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance) scope that can be used to reference this risk elsewhere in [this or other OSCAL instances](https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope). The locally defined *UUID* of the `risk` can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned [per-subject](https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency), which means it should be consistently used to identify the same subject across revisions of the document.&quot;,
      name = &quot;uuid&quot;,
      required = true,
      typeAdapter = UuidAdapter.class
  )
  private UUID _uuid;

  @BoundField(
      formalName = &quot;Risk Title&quot;,
      description = &quot;The title for this risk.&quot;,
      useName = &quot;title&quot;,
      minOccurs = 1,
      typeAdapter = MarkupLineAdapter.class
  )
  private MarkupLine _title;

  @BoundField(
      formalName = &quot;Risk Description&quot;,
      description = &quot;A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.&quot;,
      useName = &quot;description&quot;,
      minOccurs = 1,
      typeAdapter = MarkupMultilineAdapter.class
  )
  private MarkupMultiline _description;

  @BoundField(
      formalName = &quot;Risk Statement&quot;,
      description = &quot;An summary of impact for how the risk affects the system.&quot;,
      useName = &quot;statement&quot;,
      minOccurs = 1,
      typeAdapter = MarkupMultilineAdapter.class
  )
  private MarkupMultiline _statement;

  @BoundAssembly(
      formalName = &quot;Property&quot;,
      description = &quot;An attribute, characteristic, or quality of the containing object expressed as a namespace qualified name/value pair.&quot;,
      useName = &quot;prop&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;props&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;Property&gt; _props;

  @BoundAssembly(
      formalName = &quot;Link&quot;,
      description = &quot;A reference to a local or remote resource, that has a specific relation to the containing object.&quot;,
      useName = &quot;link&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;links&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;Link&gt; _links;

  @BoundField(
      formalName = &quot;Risk Status&quot;,
      description = &quot;Describes the status of the associated risk.&quot;,
      useName = &quot;status&quot;,
      minOccurs = 1,
      typeAdapter = TokenAdapter.class,
      valueConstraints = @ValueConstraints(allowedValues = @AllowedValues(level = IConstraint.Level.ERROR, allowOthers = true, values = {@AllowedValue(value = &quot;open&quot;, description = &quot;The risk has been identified.&quot;), @AllowedValue(value = &quot;investigating&quot;, description = &quot;The identified risk is being investigated. (Open risk)&quot;), @AllowedValue(value = &quot;remediating&quot;, description = &quot;Remediation activities are underway, but are not yet complete. (Open risk)&quot;), @AllowedValue(value = &quot;deviation-requested&quot;, description = &quot;A risk deviation, such as false positive, risk reduction, or operational requirement has been submitted for approval. (Open risk)&quot;), @AllowedValue(value = &quot;deviation-approved&quot;, description = &quot;A risk deviation, such as false positive, risk reduction, or operational requirement has been approved. (Open risk)&quot;), @AllowedValue(value = &quot;closed&quot;, description = &quot;The risk has been resolved.&quot;)}))
  )
  private String _status;

  @BoundAssembly(
      formalName = &quot;Origin&quot;,
      description = &quot;Identifies the source of the finding, such as a tool, interviewed person, or activity.&quot;,
      useName = &quot;origin&quot;,
      remarks = &quot;Used to identify the individual and/or tool that identified this risk.&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;origins&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;Origin&gt; _origins;

  @BoundField(
      formalName = &quot;Threat ID&quot;,
      description = &quot;A pointer, by ID, to an externally-defined threat.&quot;,
      useName = &quot;threat-id&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;threat-ids&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;ThreatId&gt; _threatIds;

  @BoundAssembly(
      formalName = &quot;Characterization&quot;,
      description = &quot;A collection of descriptive data about the containing object from a specific origin.&quot;,
      useName = &quot;characterization&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;characterizations&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;Characterization&gt; _characterizations;

  @BoundAssembly(
      formalName = &quot;Mitigating Factor&quot;,
      description = &quot;Describes an existing mitigating factor that may affect the overall determination of the risk, with an optional link to an implementation statement in the SSP.&quot;,
      useName = &quot;mitigating-factor&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;mitigating-factors&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;MitigatingFactor&gt; _mitigatingFactors;

  @BoundField(
      formalName = &quot;Risk Resolution Deadline&quot;,
      description = &quot;The date/time by which the risk must be resolved.&quot;,
      useName = &quot;deadline&quot;,
      typeAdapter = DateTimeWithTZAdapter.class
  )
  private ZonedDateTime _deadline;

  @BoundAssembly(
      formalName = &quot;Risk Response&quot;,
      description = &quot;Describes either recommended or an actual plan for addressing the risk.&quot;,
      useName = &quot;response&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;remediations&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;Response&gt; _remediations;

  @BoundAssembly(
      formalName = &quot;Risk Log&quot;,
      description = &quot;A log of all risk-related tasks taken.&quot;,
      useName = &quot;risk-log&quot;
  )
  private RiskLog _riskLog;

  @BoundAssembly(
      formalName = &quot;Related Observation&quot;,
      description = &quot;Relates the finding to a set of referenced observations that were used to determine the finding.&quot;,
      useName = &quot;related-observation&quot;,
      maxOccurs = -1,
      groupAs = @GroupAs(name = &quot;related-observations&quot;, inJson = JsonGroupAsBehavior.LIST)
  )
  private List&lt;RelatedObservation&gt; _relatedObservations;

  public Risk() {
<span class="nc" id="L185">    this(null);</span>
<span class="nc" id="L186">  }</span>

<span class="nc" id="L188">  public Risk(IMetaschemaData data) {</span>
<span class="nc" id="L189">    this.__metaschemaData = data;</span>
<span class="nc" id="L190">  }</span>

  @Override
  public IMetaschemaData getMetaschemaData() {
<span class="nc" id="L194">    return __metaschemaData;</span>
  }

  public UUID getUuid() {
<span class="nc" id="L198">    return _uuid;</span>
  }

  public void setUuid(UUID value) {
<span class="nc" id="L202">    _uuid = value;</span>
<span class="nc" id="L203">  }</span>

  public MarkupLine getTitle() {
<span class="nc" id="L206">    return _title;</span>
  }

  public void setTitle(MarkupLine value) {
<span class="nc" id="L210">    _title = value;</span>
<span class="nc" id="L211">  }</span>

  public MarkupMultiline getDescription() {
<span class="nc" id="L214">    return _description;</span>
  }

  public void setDescription(MarkupMultiline value) {
<span class="nc" id="L218">    _description = value;</span>
<span class="nc" id="L219">  }</span>

  public MarkupMultiline getStatement() {
<span class="nc" id="L222">    return _statement;</span>
  }

  public void setStatement(MarkupMultiline value) {
<span class="nc" id="L226">    _statement = value;</span>
<span class="nc" id="L227">  }</span>

  public List&lt;Property&gt; getProps() {
<span class="nc" id="L230">    return _props;</span>
  }

  public void setProps(List&lt;Property&gt; value) {
<span class="nc" id="L234">    _props = value;</span>
<span class="nc" id="L235">  }</span>

  /**
   * Add a new {@link Property} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addProp(Property item) {
<span class="nc" id="L243">    Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">    if (_props == null) {</span>
<span class="nc" id="L245">      _props = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L247">    return _props.add(value);</span>
  }

  /**
   * Remove the first matching {@link Property} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeProp(Property item) {
<span class="nc" id="L256">    Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">    return _props != null &amp;&amp; _props.remove(value);</span>
  }

  public List&lt;Link&gt; getLinks() {
<span class="nc" id="L261">    return _links;</span>
  }

  public void setLinks(List&lt;Link&gt; value) {
<span class="nc" id="L265">    _links = value;</span>
<span class="nc" id="L266">  }</span>

  /**
   * Add a new {@link Link} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addLink(Link item) {
<span class="nc" id="L274">    Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">    if (_links == null) {</span>
<span class="nc" id="L276">      _links = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L278">    return _links.add(value);</span>
  }

  /**
   * Remove the first matching {@link Link} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeLink(Link item) {
<span class="nc" id="L287">    Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">    return _links != null &amp;&amp; _links.remove(value);</span>
  }

  public String getStatus() {
<span class="nc" id="L292">    return _status;</span>
  }

  public void setStatus(String value) {
<span class="nc" id="L296">    _status = value;</span>
<span class="nc" id="L297">  }</span>

  public List&lt;Origin&gt; getOrigins() {
<span class="nc" id="L300">    return _origins;</span>
  }

  public void setOrigins(List&lt;Origin&gt; value) {
<span class="nc" id="L304">    _origins = value;</span>
<span class="nc" id="L305">  }</span>

  /**
   * Add a new {@link Origin} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addOrigin(Origin item) {
<span class="nc" id="L313">    Origin value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (_origins == null) {</span>
<span class="nc" id="L315">      _origins = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L317">    return _origins.add(value);</span>
  }

  /**
   * Remove the first matching {@link Origin} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeOrigin(Origin item) {
<span class="nc" id="L326">    Origin value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L327" title="All 4 branches missed.">    return _origins != null &amp;&amp; _origins.remove(value);</span>
  }

  public List&lt;ThreatId&gt; getThreatIds() {
<span class="nc" id="L331">    return _threatIds;</span>
  }

  public void setThreatIds(List&lt;ThreatId&gt; value) {
<span class="nc" id="L335">    _threatIds = value;</span>
<span class="nc" id="L336">  }</span>

  /**
   * Add a new {@link ThreatId} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addThreatId(ThreatId item) {
<span class="nc" id="L344">    ThreatId value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">    if (_threatIds == null) {</span>
<span class="nc" id="L346">      _threatIds = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L348">    return _threatIds.add(value);</span>
  }

  /**
   * Remove the first matching {@link ThreatId} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeThreatId(ThreatId item) {
<span class="nc" id="L357">    ThreatId value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">    return _threatIds != null &amp;&amp; _threatIds.remove(value);</span>
  }

  public List&lt;Characterization&gt; getCharacterizations() {
<span class="nc" id="L362">    return _characterizations;</span>
  }

  public void setCharacterizations(List&lt;Characterization&gt; value) {
<span class="nc" id="L366">    _characterizations = value;</span>
<span class="nc" id="L367">  }</span>

  /**
   * Add a new {@link Characterization} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addCharacterization(Characterization item) {
<span class="nc" id="L375">    Characterization value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">    if (_characterizations == null) {</span>
<span class="nc" id="L377">      _characterizations = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L379">    return _characterizations.add(value);</span>
  }

  /**
   * Remove the first matching {@link Characterization} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeCharacterization(Characterization item) {
<span class="nc" id="L388">    Characterization value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L389" title="All 4 branches missed.">    return _characterizations != null &amp;&amp; _characterizations.remove(value);</span>
  }

  public List&lt;MitigatingFactor&gt; getMitigatingFactors() {
<span class="nc" id="L393">    return _mitigatingFactors;</span>
  }

  public void setMitigatingFactors(List&lt;MitigatingFactor&gt; value) {
<span class="nc" id="L397">    _mitigatingFactors = value;</span>
<span class="nc" id="L398">  }</span>

  /**
   * Add a new {@link MitigatingFactor} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addMitigatingFactor(MitigatingFactor item) {
<span class="nc" id="L406">    MitigatingFactor value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">    if (_mitigatingFactors == null) {</span>
<span class="nc" id="L408">      _mitigatingFactors = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L410">    return _mitigatingFactors.add(value);</span>
  }

  /**
   * Remove the first matching {@link MitigatingFactor} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeMitigatingFactor(MitigatingFactor item) {
<span class="nc" id="L419">    MitigatingFactor value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">    return _mitigatingFactors != null &amp;&amp; _mitigatingFactors.remove(value);</span>
  }

  public ZonedDateTime getDeadline() {
<span class="nc" id="L424">    return _deadline;</span>
  }

  public void setDeadline(ZonedDateTime value) {
<span class="nc" id="L428">    _deadline = value;</span>
<span class="nc" id="L429">  }</span>

  public List&lt;Response&gt; getRemediations() {
<span class="nc" id="L432">    return _remediations;</span>
  }

  public void setRemediations(List&lt;Response&gt; value) {
<span class="nc" id="L436">    _remediations = value;</span>
<span class="nc" id="L437">  }</span>

  /**
   * Add a new {@link Response} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addResponse(Response item) {
<span class="nc" id="L445">    Response value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">    if (_remediations == null) {</span>
<span class="nc" id="L447">      _remediations = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L449">    return _remediations.add(value);</span>
  }

  /**
   * Remove the first matching {@link Response} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeResponse(Response item) {
<span class="nc" id="L458">    Response value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L459" title="All 4 branches missed.">    return _remediations != null &amp;&amp; _remediations.remove(value);</span>
  }

  public RiskLog getRiskLog() {
<span class="nc" id="L463">    return _riskLog;</span>
  }

  public void setRiskLog(RiskLog value) {
<span class="nc" id="L467">    _riskLog = value;</span>
<span class="nc" id="L468">  }</span>

  public List&lt;RelatedObservation&gt; getRelatedObservations() {
<span class="nc" id="L471">    return _relatedObservations;</span>
  }

  public void setRelatedObservations(List&lt;RelatedObservation&gt; value) {
<span class="nc" id="L475">    _relatedObservations = value;</span>
<span class="nc" id="L476">  }</span>

  /**
   * Add a new {@link RelatedObservation} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addRelatedObservation(RelatedObservation item) {
<span class="nc" id="L484">    RelatedObservation value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">    if (_relatedObservations == null) {</span>
<span class="nc" id="L486">      _relatedObservations = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L488">    return _relatedObservations.add(value);</span>
  }

  /**
   * Remove the first matching {@link RelatedObservation} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeRelatedObservation(RelatedObservation item) {
<span class="nc" id="L497">    RelatedObservation value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">    return _relatedObservations != null &amp;&amp; _relatedObservations.remove(value);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L503">    return new ReflectionToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).toString();</span>
  }

  /**
   * Describes an existing mitigating factor that may affect the overall determination of the risk, with an optional link to an implementation statement in the SSP.
   */
  @MetaschemaAssembly(
      formalName = &quot;Mitigating Factor&quot;,
      description = &quot;Describes an existing mitigating factor that may affect the overall determination of the risk, with an optional link to an implementation statement in the SSP.&quot;,
      name = &quot;mitigating-factor&quot;,
      moduleClass = OscalAssessmentCommonModule.class
  )
  public static class MitigatingFactor implements IBoundObject {
    private final IMetaschemaData __metaschemaData;

    /**
     * &quot;A &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented\&quot;&gt;machine-oriented&lt;/a&gt;, &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique\&quot;&gt;globally unique&lt;/a&gt; identifier with &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance\&quot;&gt;cross-instance&lt;/a&gt; scope that can be used to reference this mitigating factor elsewhere in &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope\&quot;&gt;this or other OSCAL instances&lt;/a&gt;. The locally defined &lt;em&gt;UUID&lt;/em&gt; of the &lt;code&gt;mitigating factor&lt;/code&gt; can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency\&quot;&gt;per-subject&lt;/a&gt;, which means it should be consistently used to identify the same subject across revisions of the document.&quot;
     */
    @BoundFlag(
        formalName = &quot;Mitigating Factor Universally Unique Identifier&quot;,
        description = &quot;A [machine-oriented](https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented), [globally unique](https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique) identifier with [cross-instance](https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance) scope that can be used to reference this mitigating factor elsewhere in [this or other OSCAL instances](https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope). The locally defined *UUID* of the `mitigating factor` can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned [per-subject](https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency), which means it should be consistently used to identify the same subject across revisions of the document.&quot;,
        name = &quot;uuid&quot;,
        required = true,
        typeAdapter = UuidAdapter.class
    )
    private UUID _uuid;

    /**
     * &quot;A &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented\&quot;&gt;machine-oriented&lt;/a&gt;, &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique\&quot;&gt;globally unique&lt;/a&gt; identifier with &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance\&quot;&gt;cross-instance&lt;/a&gt; scope that can be used to reference this implementation statement elsewhere in &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope\&quot;&gt;this or other OSCAL instances&lt;/a&gt;s. The locally defined &lt;em&gt;UUID&lt;/em&gt; of the &lt;code&gt;implementation statement&lt;/code&gt; can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency\&quot;&gt;per-subject&lt;/a&gt;, which means it should be consistently used to identify the same subject across revisions of the document.&quot;
     */
    @BoundFlag(
        formalName = &quot;Implementation UUID&quot;,
        description = &quot;A [machine-oriented](https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented), [globally unique](https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique) identifier with [cross-instance](https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance) scope that can be used to reference this implementation statement elsewhere in [this or other OSCAL instances](https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope)s. The locally defined *UUID* of the `implementation statement` can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned [per-subject](https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency), which means it should be consistently used to identify the same subject across revisions of the document.&quot;,
        name = &quot;implementation-uuid&quot;,
        typeAdapter = UuidAdapter.class
    )
    private UUID _implementationUuid;

    @BoundField(
        formalName = &quot;Mitigating Factor Description&quot;,
        description = &quot;A human-readable description of this mitigating factor.&quot;,
        useName = &quot;description&quot;,
        minOccurs = 1,
        typeAdapter = MarkupMultilineAdapter.class
    )
    private MarkupMultiline _description;

    @BoundAssembly(
        formalName = &quot;Property&quot;,
        description = &quot;An attribute, characteristic, or quality of the containing object expressed as a namespace qualified name/value pair.&quot;,
        useName = &quot;prop&quot;,
        maxOccurs = -1,
        groupAs = @GroupAs(name = &quot;props&quot;, inJson = JsonGroupAsBehavior.LIST)
    )
    private List&lt;Property&gt; _props;

    @BoundAssembly(
        formalName = &quot;Link&quot;,
        description = &quot;A reference to a local or remote resource, that has a specific relation to the containing object.&quot;,
        useName = &quot;link&quot;,
        maxOccurs = -1,
        groupAs = @GroupAs(name = &quot;links&quot;, inJson = JsonGroupAsBehavior.LIST)
    )
    private List&lt;Link&gt; _links;

    @BoundAssembly(
        formalName = &quot;Identifies the Subject&quot;,
        description = &quot;A [human-oriented](https://pages.nist.gov/OSCAL/concepts/identifier-use/#human-oriented) identifier reference to a resource. Use type to indicate whether the identified resource is a component, inventory item, location, user, or something else.&quot;,
        useName = &quot;subject&quot;,
        remarks = &quot;Links identifiable elements of the system to this mitigating factor, such as an inventory-item or component.&quot;,
        maxOccurs = -1,
        groupAs = @GroupAs(name = &quot;subjects&quot;, inJson = JsonGroupAsBehavior.LIST)
    )
    private List&lt;SubjectReference&gt; _subjects;

    public MitigatingFactor() {
<span class="nc" id="L579">      this(null);</span>
<span class="nc" id="L580">    }</span>

<span class="nc" id="L582">    public MitigatingFactor(IMetaschemaData data) {</span>
<span class="nc" id="L583">      this.__metaschemaData = data;</span>
<span class="nc" id="L584">    }</span>

    @Override
    public IMetaschemaData getMetaschemaData() {
<span class="nc" id="L588">      return __metaschemaData;</span>
    }

    public UUID getUuid() {
<span class="nc" id="L592">      return _uuid;</span>
    }

    public void setUuid(UUID value) {
<span class="nc" id="L596">      _uuid = value;</span>
<span class="nc" id="L597">    }</span>

    public UUID getImplementationUuid() {
<span class="nc" id="L600">      return _implementationUuid;</span>
    }

    public void setImplementationUuid(UUID value) {
<span class="nc" id="L604">      _implementationUuid = value;</span>
<span class="nc" id="L605">    }</span>

    public MarkupMultiline getDescription() {
<span class="nc" id="L608">      return _description;</span>
    }

    public void setDescription(MarkupMultiline value) {
<span class="nc" id="L612">      _description = value;</span>
<span class="nc" id="L613">    }</span>

    public List&lt;Property&gt; getProps() {
<span class="nc" id="L616">      return _props;</span>
    }

    public void setProps(List&lt;Property&gt; value) {
<span class="nc" id="L620">      _props = value;</span>
<span class="nc" id="L621">    }</span>

    /**
     * Add a new {@link Property} item to the underlying collection.
     * @param item the item to add
     * @return {@code true}
     */
    public boolean addProp(Property item) {
<span class="nc" id="L629">      Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">      if (_props == null) {</span>
<span class="nc" id="L631">        _props = new LinkedList&lt;&gt;();</span>
      }
<span class="nc" id="L633">      return _props.add(value);</span>
    }

    /**
     * Remove the first matching {@link Property} item from the underlying collection.
     * @param item the item to remove
     * @return {@code true} if the item was removed or {@code false} otherwise
     */
    public boolean removeProp(Property item) {
<span class="nc" id="L642">      Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L643" title="All 4 branches missed.">      return _props != null &amp;&amp; _props.remove(value);</span>
    }

    public List&lt;Link&gt; getLinks() {
<span class="nc" id="L647">      return _links;</span>
    }

    public void setLinks(List&lt;Link&gt; value) {
<span class="nc" id="L651">      _links = value;</span>
<span class="nc" id="L652">    }</span>

    /**
     * Add a new {@link Link} item to the underlying collection.
     * @param item the item to add
     * @return {@code true}
     */
    public boolean addLink(Link item) {
<span class="nc" id="L660">      Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">      if (_links == null) {</span>
<span class="nc" id="L662">        _links = new LinkedList&lt;&gt;();</span>
      }
<span class="nc" id="L664">      return _links.add(value);</span>
    }

    /**
     * Remove the first matching {@link Link} item from the underlying collection.
     * @param item the item to remove
     * @return {@code true} if the item was removed or {@code false} otherwise
     */
    public boolean removeLink(Link item) {
<span class="nc" id="L673">      Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">      return _links != null &amp;&amp; _links.remove(value);</span>
    }

    public List&lt;SubjectReference&gt; getSubjects() {
<span class="nc" id="L678">      return _subjects;</span>
    }

    public void setSubjects(List&lt;SubjectReference&gt; value) {
<span class="nc" id="L682">      _subjects = value;</span>
<span class="nc" id="L683">    }</span>

    /**
     * Add a new {@link SubjectReference} item to the underlying collection.
     * @param item the item to add
     * @return {@code true}
     */
    public boolean addSubject(SubjectReference item) {
<span class="nc" id="L691">      SubjectReference value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">      if (_subjects == null) {</span>
<span class="nc" id="L693">        _subjects = new LinkedList&lt;&gt;();</span>
      }
<span class="nc" id="L695">      return _subjects.add(value);</span>
    }

    /**
     * Remove the first matching {@link SubjectReference} item from the underlying collection.
     * @param item the item to remove
     * @return {@code true} if the item was removed or {@code false} otherwise
     */
    public boolean removeSubject(SubjectReference item) {
<span class="nc" id="L704">      SubjectReference value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L705" title="All 4 branches missed.">      return _subjects != null &amp;&amp; _subjects.remove(value);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L710">      return new ReflectionToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).toString();</span>
    }
  }

  /**
   * A log of all risk-related tasks taken.
   */
  @MetaschemaAssembly(
      formalName = &quot;Risk Log&quot;,
      description = &quot;A log of all risk-related tasks taken.&quot;,
      name = &quot;risk-log&quot;,
      moduleClass = OscalAssessmentCommonModule.class
  )
  public static class RiskLog implements IBoundObject {
    private final IMetaschemaData __metaschemaData;

    @BoundAssembly(
        formalName = &quot;Risk Log Entry&quot;,
        description = &quot;Identifies an individual risk response that occurred as part of managing an identified risk.&quot;,
        useName = &quot;entry&quot;,
        minOccurs = 1,
        maxOccurs = -1,
        groupAs = @GroupAs(name = &quot;entries&quot;, inJson = JsonGroupAsBehavior.LIST)
    )
    private List&lt;Entry&gt; _entries;

    public RiskLog() {
<span class="nc" id="L737">      this(null);</span>
<span class="nc" id="L738">    }</span>

<span class="nc" id="L740">    public RiskLog(IMetaschemaData data) {</span>
<span class="nc" id="L741">      this.__metaschemaData = data;</span>
<span class="nc" id="L742">    }</span>

    @Override
    public IMetaschemaData getMetaschemaData() {
<span class="nc" id="L746">      return __metaschemaData;</span>
    }

    public List&lt;Entry&gt; getEntries() {
<span class="nc" id="L750">      return _entries;</span>
    }

    public void setEntries(List&lt;Entry&gt; value) {
<span class="nc" id="L754">      _entries = value;</span>
<span class="nc" id="L755">    }</span>

    /**
     * Add a new {@link Entry} item to the underlying collection.
     * @param item the item to add
     * @return {@code true}
     */
    public boolean addEntry(Entry item) {
<span class="nc" id="L763">      Entry value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">      if (_entries == null) {</span>
<span class="nc" id="L765">        _entries = new LinkedList&lt;&gt;();</span>
      }
<span class="nc" id="L767">      return _entries.add(value);</span>
    }

    /**
     * Remove the first matching {@link Entry} item from the underlying collection.
     * @param item the item to remove
     * @return {@code true} if the item was removed or {@code false} otherwise
     */
    public boolean removeEntry(Entry item) {
<span class="nc" id="L776">      Entry value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L777" title="All 4 branches missed.">      return _entries != null &amp;&amp; _entries.remove(value);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L782">      return new ReflectionToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).toString();</span>
    }

    /**
     * Identifies an individual risk response that occurred as part of managing an identified risk.
     */
    @MetaschemaAssembly(
        formalName = &quot;Risk Log Entry&quot;,
        description = &quot;Identifies an individual risk response that occurred as part of managing an identified risk.&quot;,
        name = &quot;entry&quot;,
        moduleClass = OscalAssessmentCommonModule.class,
        valueConstraints = @ValueConstraints(allowedValues = {@AllowedValues(level = IConstraint.Level.ERROR, target = &quot;prop[has-oscal-namespace('http://csrc.nist.gov/ns/oscal')]/@name&quot;, values = @AllowedValue(value = &quot;type&quot;, description = &quot;The type of remediation tracking entry. Can be multi-valued.&quot;)), @AllowedValues(level = IConstraint.Level.ERROR, target = &quot;prop[has-oscal-namespace('http://csrc.nist.gov/ns/oscal') and @name='type']/@value&quot;, allowOthers = true, values = {@AllowedValue(value = &quot;vendor-check-in&quot;, description = &quot;Contacted vendor to determine the status of a pending fix to a known vulnerability.&quot;), @AllowedValue(value = &quot;status-update&quot;, description = &quot;Information related to the current state of response to this risk.&quot;), @AllowedValue(value = &quot;milestone-complete&quot;, description = &quot;A significant step in the response plan has been achieved.&quot;), @AllowedValue(value = &quot;mitigation&quot;, description = &quot;An activity was completed that reduces the likelihood or impact of this risk.&quot;), @AllowedValue(value = &quot;remediated&quot;, description = &quot;An activity was completed that eliminates the likelihood or impact of this risk.&quot;), @AllowedValue(value = &quot;closed&quot;, description = &quot;The risk is no longer applicable to the system.&quot;), @AllowedValue(value = &quot;dr-submission&quot;, description = &quot;A deviation request was made to the authorizing official.&quot;), @AllowedValue(value = &quot;dr-updated&quot;, description = &quot;A previously submitted deviation request has been modified.&quot;), @AllowedValue(value = &quot;dr-approved&quot;, description = &quot;The authorizing official approved the deviation.&quot;), @AllowedValue(value = &quot;dr-rejected&quot;, description = &quot;The authorizing official rejected the deviation.&quot;)})})
    )
    public static class Entry implements IBoundObject {
      private final IMetaschemaData __metaschemaData;

      /**
       * &quot;A &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented\&quot;&gt;machine-oriented&lt;/a&gt;, &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique\&quot;&gt;globally unique&lt;/a&gt; identifier with &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance\&quot;&gt;cross-instance&lt;/a&gt; scope that can be used to reference this risk log entry elsewhere in &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope\&quot;&gt;this or other OSCAL instances&lt;/a&gt;. The locally defined &lt;em&gt;UUID&lt;/em&gt; of the &lt;code&gt;risk log entry&lt;/code&gt; can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency\&quot;&gt;per-subject&lt;/a&gt;, which means it should be consistently used to identify the same subject across revisions of the document.&quot;
       */
      @BoundFlag(
          formalName = &quot;Risk Log Entry Universally Unique Identifier&quot;,
          description = &quot;A [machine-oriented](https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented), [globally unique](https://pages.nist.gov/OSCAL/concepts/identifier-use/#globally-unique) identifier with [cross-instance](https://pages.nist.gov/OSCAL/concepts/identifier-use/#cross-instance) scope that can be used to reference this risk log entry elsewhere in [this or other OSCAL instances](https://pages.nist.gov/OSCAL/concepts/identifier-use/#scope). The locally defined *UUID* of the `risk log entry` can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned [per-subject](https://pages.nist.gov/OSCAL/concepts/identifier-use/#consistency), which means it should be consistently used to identify the same subject across revisions of the document.&quot;,
          name = &quot;uuid&quot;,
          required = true,
          typeAdapter = UuidAdapter.class
      )
      private UUID _uuid;

      @BoundField(
          formalName = &quot;Title&quot;,
          description = &quot;The title for this risk log entry.&quot;,
          useName = &quot;title&quot;,
          typeAdapter = MarkupLineAdapter.class
      )
      private MarkupLine _title;

      @BoundField(
          formalName = &quot;Risk Task Description&quot;,
          description = &quot;A human-readable description of what was done regarding the risk.&quot;,
          useName = &quot;description&quot;,
          typeAdapter = MarkupMultilineAdapter.class
      )
      private MarkupMultiline _description;

      @BoundField(
          formalName = &quot;Start&quot;,
          description = &quot;Identifies the start date and time of the event.&quot;,
          useName = &quot;start&quot;,
          minOccurs = 1,
          typeAdapter = DateTimeWithTZAdapter.class
      )
      private ZonedDateTime _start;

      @BoundField(
          formalName = &quot;End&quot;,
          description = &quot;Identifies the end date and time of the event. If the event is a point in time, the start and end will be the same date and time.&quot;,
          useName = &quot;end&quot;,
          typeAdapter = DateTimeWithTZAdapter.class
      )
      private ZonedDateTime _end;

      @BoundAssembly(
          formalName = &quot;Property&quot;,
          description = &quot;An attribute, characteristic, or quality of the containing object expressed as a namespace qualified name/value pair.&quot;,
          useName = &quot;prop&quot;,
          maxOccurs = -1,
          groupAs = @GroupAs(name = &quot;props&quot;, inJson = JsonGroupAsBehavior.LIST)
      )
      private List&lt;Property&gt; _props;

      @BoundAssembly(
          formalName = &quot;Link&quot;,
          description = &quot;A reference to a local or remote resource, that has a specific relation to the containing object.&quot;,
          useName = &quot;link&quot;,
          maxOccurs = -1,
          groupAs = @GroupAs(name = &quot;links&quot;, inJson = JsonGroupAsBehavior.LIST)
      )
      private List&lt;Link&gt; _links;

      @BoundAssembly(
          formalName = &quot;Logged By&quot;,
          description = &quot;Used to indicate who created a log entry in what role.&quot;,
          useName = &quot;logged-by&quot;,
          maxOccurs = -1,
          groupAs = @GroupAs(name = &quot;logged-by&quot;, inJson = JsonGroupAsBehavior.LIST)
      )
      private List&lt;LoggedBy&gt; _loggedBy;

      @BoundField(
          formalName = &quot;Risk Status&quot;,
          description = &quot;Describes the status of the associated risk.&quot;,
          useName = &quot;status-change&quot;,
          remarks = &quot;Identifies a change in risk status made resulting from the task described by this risk log entry. This allows the risk's status history to be captured as a sequence of risk log entries.&quot;,
          typeAdapter = TokenAdapter.class,
          valueConstraints = @ValueConstraints(allowedValues = @AllowedValues(level = IConstraint.Level.ERROR, allowOthers = true, values = {@AllowedValue(value = &quot;open&quot;, description = &quot;The risk has been identified.&quot;), @AllowedValue(value = &quot;investigating&quot;, description = &quot;The identified risk is being investigated. (Open risk)&quot;), @AllowedValue(value = &quot;remediating&quot;, description = &quot;Remediation activities are underway, but are not yet complete. (Open risk)&quot;), @AllowedValue(value = &quot;deviation-requested&quot;, description = &quot;A risk deviation, such as false positive, risk reduction, or operational requirement has been submitted for approval. (Open risk)&quot;), @AllowedValue(value = &quot;deviation-approved&quot;, description = &quot;A risk deviation, such as false positive, risk reduction, or operational requirement has been approved. (Open risk)&quot;), @AllowedValue(value = &quot;closed&quot;, description = &quot;The risk has been resolved.&quot;)}))
      )
      private String _statusChange;

      @BoundAssembly(
          formalName = &quot;Risk Response Reference&quot;,
          description = &quot;Identifies an individual risk response that this log entry is for.&quot;,
          useName = &quot;related-response&quot;,
          maxOccurs = -1,
          groupAs = @GroupAs(name = &quot;related-responses&quot;, inJson = JsonGroupAsBehavior.LIST)
      )
      private List&lt;RelatedResponse&gt; _relatedResponses;

      @BoundField(
          formalName = &quot;Remarks&quot;,
          description = &quot;Additional commentary about the containing object.&quot;,
          useName = &quot;remarks&quot;,
          typeAdapter = MarkupMultilineAdapter.class
      )
      private MarkupMultiline _remarks;

      public Entry() {
<span class="nc" id="L898">        this(null);</span>
<span class="nc" id="L899">      }</span>

<span class="nc" id="L901">      public Entry(IMetaschemaData data) {</span>
<span class="nc" id="L902">        this.__metaschemaData = data;</span>
<span class="nc" id="L903">      }</span>

      @Override
      public IMetaschemaData getMetaschemaData() {
<span class="nc" id="L907">        return __metaschemaData;</span>
      }

      public UUID getUuid() {
<span class="nc" id="L911">        return _uuid;</span>
      }

      public void setUuid(UUID value) {
<span class="nc" id="L915">        _uuid = value;</span>
<span class="nc" id="L916">      }</span>

      public MarkupLine getTitle() {
<span class="nc" id="L919">        return _title;</span>
      }

      public void setTitle(MarkupLine value) {
<span class="nc" id="L923">        _title = value;</span>
<span class="nc" id="L924">      }</span>

      public MarkupMultiline getDescription() {
<span class="nc" id="L927">        return _description;</span>
      }

      public void setDescription(MarkupMultiline value) {
<span class="nc" id="L931">        _description = value;</span>
<span class="nc" id="L932">      }</span>

      public ZonedDateTime getStart() {
<span class="nc" id="L935">        return _start;</span>
      }

      public void setStart(ZonedDateTime value) {
<span class="nc" id="L939">        _start = value;</span>
<span class="nc" id="L940">      }</span>

      public ZonedDateTime getEnd() {
<span class="nc" id="L943">        return _end;</span>
      }

      public void setEnd(ZonedDateTime value) {
<span class="nc" id="L947">        _end = value;</span>
<span class="nc" id="L948">      }</span>

      public List&lt;Property&gt; getProps() {
<span class="nc" id="L951">        return _props;</span>
      }

      public void setProps(List&lt;Property&gt; value) {
<span class="nc" id="L955">        _props = value;</span>
<span class="nc" id="L956">      }</span>

      /**
       * Add a new {@link Property} item to the underlying collection.
       * @param item the item to add
       * @return {@code true}
       */
      public boolean addProp(Property item) {
<span class="nc" id="L964">        Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">        if (_props == null) {</span>
<span class="nc" id="L966">          _props = new LinkedList&lt;&gt;();</span>
        }
<span class="nc" id="L968">        return _props.add(value);</span>
      }

      /**
       * Remove the first matching {@link Property} item from the underlying collection.
       * @param item the item to remove
       * @return {@code true} if the item was removed or {@code false} otherwise
       */
      public boolean removeProp(Property item) {
<span class="nc" id="L977">        Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L978" title="All 4 branches missed.">        return _props != null &amp;&amp; _props.remove(value);</span>
      }

      public List&lt;Link&gt; getLinks() {
<span class="nc" id="L982">        return _links;</span>
      }

      public void setLinks(List&lt;Link&gt; value) {
<span class="nc" id="L986">        _links = value;</span>
<span class="nc" id="L987">      }</span>

      /**
       * Add a new {@link Link} item to the underlying collection.
       * @param item the item to add
       * @return {@code true}
       */
      public boolean addLink(Link item) {
<span class="nc" id="L995">        Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">        if (_links == null) {</span>
<span class="nc" id="L997">          _links = new LinkedList&lt;&gt;();</span>
        }
<span class="nc" id="L999">        return _links.add(value);</span>
      }

      /**
       * Remove the first matching {@link Link} item from the underlying collection.
       * @param item the item to remove
       * @return {@code true} if the item was removed or {@code false} otherwise
       */
      public boolean removeLink(Link item) {
<span class="nc" id="L1008">        Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1009" title="All 4 branches missed.">        return _links != null &amp;&amp; _links.remove(value);</span>
      }

      public List&lt;LoggedBy&gt; getLoggedBy() {
<span class="nc" id="L1013">        return _loggedBy;</span>
      }

      public void setLoggedBy(List&lt;LoggedBy&gt; value) {
<span class="nc" id="L1017">        _loggedBy = value;</span>
<span class="nc" id="L1018">      }</span>

      /**
       * Add a new {@link LoggedBy} item to the underlying collection.
       * @param item the item to add
       * @return {@code true}
       */
      public boolean addLoggedBy(LoggedBy item) {
<span class="nc" id="L1026">        LoggedBy value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        if (_loggedBy == null) {</span>
<span class="nc" id="L1028">          _loggedBy = new LinkedList&lt;&gt;();</span>
        }
<span class="nc" id="L1030">        return _loggedBy.add(value);</span>
      }

      /**
       * Remove the first matching {@link LoggedBy} item from the underlying collection.
       * @param item the item to remove
       * @return {@code true} if the item was removed or {@code false} otherwise
       */
      public boolean removeLoggedBy(LoggedBy item) {
<span class="nc" id="L1039">        LoggedBy value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1040" title="All 4 branches missed.">        return _loggedBy != null &amp;&amp; _loggedBy.remove(value);</span>
      }

      public String getStatusChange() {
<span class="nc" id="L1044">        return _statusChange;</span>
      }

      public void setStatusChange(String value) {
<span class="nc" id="L1048">        _statusChange = value;</span>
<span class="nc" id="L1049">      }</span>

      public List&lt;RelatedResponse&gt; getRelatedResponses() {
<span class="nc" id="L1052">        return _relatedResponses;</span>
      }

      public void setRelatedResponses(List&lt;RelatedResponse&gt; value) {
<span class="nc" id="L1056">        _relatedResponses = value;</span>
<span class="nc" id="L1057">      }</span>

      /**
       * Add a new {@link RelatedResponse} item to the underlying collection.
       * @param item the item to add
       * @return {@code true}
       */
      public boolean addRelatedResponse(RelatedResponse item) {
<span class="nc" id="L1065">        RelatedResponse value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (_relatedResponses == null) {</span>
<span class="nc" id="L1067">          _relatedResponses = new LinkedList&lt;&gt;();</span>
        }
<span class="nc" id="L1069">        return _relatedResponses.add(value);</span>
      }

      /**
       * Remove the first matching {@link RelatedResponse} item from the underlying collection.
       * @param item the item to remove
       * @return {@code true} if the item was removed or {@code false} otherwise
       */
      public boolean removeRelatedResponse(RelatedResponse item) {
<span class="nc" id="L1078">        RelatedResponse value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1079" title="All 4 branches missed.">        return _relatedResponses != null &amp;&amp; _relatedResponses.remove(value);</span>
      }

      public MarkupMultiline getRemarks() {
<span class="nc" id="L1083">        return _remarks;</span>
      }

      public void setRemarks(MarkupMultiline value) {
<span class="nc" id="L1087">        _remarks = value;</span>
<span class="nc" id="L1088">      }</span>

      @Override
      public String toString() {
<span class="nc" id="L1092">        return new ReflectionToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).toString();</span>
      }

      /**
       * Identifies an individual risk response that this log entry is for.
       */
      @MetaschemaAssembly(
          formalName = &quot;Risk Response Reference&quot;,
          description = &quot;Identifies an individual risk response that this log entry is for.&quot;,
          name = &quot;related-response&quot;,
          moduleClass = OscalAssessmentCommonModule.class
      )
      public static class RelatedResponse implements IBoundObject {
        private final IMetaschemaData __metaschemaData;

        /**
         * &quot;A &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented\&quot;&gt;machine-oriented&lt;/a&gt; identifier reference to a unique risk response.&quot;
         */
        @BoundFlag(
            formalName = &quot;Response Universally Unique Identifier Reference&quot;,
            description = &quot;A [machine-oriented](https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented) identifier reference to a unique risk response.&quot;,
            name = &quot;response-uuid&quot;,
            required = true,
            typeAdapter = UuidAdapter.class
        )
        private UUID _responseUuid;

        @BoundAssembly(
            formalName = &quot;Property&quot;,
            description = &quot;An attribute, characteristic, or quality of the containing object expressed as a namespace qualified name/value pair.&quot;,
            useName = &quot;prop&quot;,
            maxOccurs = -1,
            groupAs = @GroupAs(name = &quot;props&quot;, inJson = JsonGroupAsBehavior.LIST)
        )
        private List&lt;Property&gt; _props;

        @BoundAssembly(
            formalName = &quot;Link&quot;,
            description = &quot;A reference to a local or remote resource, that has a specific relation to the containing object.&quot;,
            useName = &quot;link&quot;,
            maxOccurs = -1,
            groupAs = @GroupAs(name = &quot;links&quot;, inJson = JsonGroupAsBehavior.LIST)
        )
        private List&lt;Link&gt; _links;

        @BoundAssembly(
            formalName = &quot;Task Reference&quot;,
            description = &quot;Identifies an individual task for which the containing object is a consequence of.&quot;,
            useName = &quot;related-task&quot;,
            remarks = &quot;This is used to identify the task(s) that this log entry was generated for.&quot;,
            maxOccurs = -1,
            groupAs = @GroupAs(name = &quot;related-tasks&quot;, inJson = JsonGroupAsBehavior.LIST)
        )
        private List&lt;RelatedTask&gt; _relatedTasks;

        @BoundField(
            formalName = &quot;Remarks&quot;,
            description = &quot;Additional commentary about the containing object.&quot;,
            useName = &quot;remarks&quot;,
            typeAdapter = MarkupMultilineAdapter.class
        )
        private MarkupMultiline _remarks;

        public RelatedResponse() {
<span class="nc" id="L1156">          this(null);</span>
<span class="nc" id="L1157">        }</span>

<span class="nc" id="L1159">        public RelatedResponse(IMetaschemaData data) {</span>
<span class="nc" id="L1160">          this.__metaschemaData = data;</span>
<span class="nc" id="L1161">        }</span>

        @Override
        public IMetaschemaData getMetaschemaData() {
<span class="nc" id="L1165">          return __metaschemaData;</span>
        }

        public UUID getResponseUuid() {
<span class="nc" id="L1169">          return _responseUuid;</span>
        }

        public void setResponseUuid(UUID value) {
<span class="nc" id="L1173">          _responseUuid = value;</span>
<span class="nc" id="L1174">        }</span>

        public List&lt;Property&gt; getProps() {
<span class="nc" id="L1177">          return _props;</span>
        }

        public void setProps(List&lt;Property&gt; value) {
<span class="nc" id="L1181">          _props = value;</span>
<span class="nc" id="L1182">        }</span>

        /**
         * Add a new {@link Property} item to the underlying collection.
         * @param item the item to add
         * @return {@code true}
         */
        public boolean addProp(Property item) {
<span class="nc" id="L1190">          Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">          if (_props == null) {</span>
<span class="nc" id="L1192">            _props = new LinkedList&lt;&gt;();</span>
          }
<span class="nc" id="L1194">          return _props.add(value);</span>
        }

        /**
         * Remove the first matching {@link Property} item from the underlying collection.
         * @param item the item to remove
         * @return {@code true} if the item was removed or {@code false} otherwise
         */
        public boolean removeProp(Property item) {
<span class="nc" id="L1203">          Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1204" title="All 4 branches missed.">          return _props != null &amp;&amp; _props.remove(value);</span>
        }

        public List&lt;Link&gt; getLinks() {
<span class="nc" id="L1208">          return _links;</span>
        }

        public void setLinks(List&lt;Link&gt; value) {
<span class="nc" id="L1212">          _links = value;</span>
<span class="nc" id="L1213">        }</span>

        /**
         * Add a new {@link Link} item to the underlying collection.
         * @param item the item to add
         * @return {@code true}
         */
        public boolean addLink(Link item) {
<span class="nc" id="L1221">          Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">          if (_links == null) {</span>
<span class="nc" id="L1223">            _links = new LinkedList&lt;&gt;();</span>
          }
<span class="nc" id="L1225">          return _links.add(value);</span>
        }

        /**
         * Remove the first matching {@link Link} item from the underlying collection.
         * @param item the item to remove
         * @return {@code true} if the item was removed or {@code false} otherwise
         */
        public boolean removeLink(Link item) {
<span class="nc" id="L1234">          Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1235" title="All 4 branches missed.">          return _links != null &amp;&amp; _links.remove(value);</span>
        }

        public List&lt;RelatedTask&gt; getRelatedTasks() {
<span class="nc" id="L1239">          return _relatedTasks;</span>
        }

        public void setRelatedTasks(List&lt;RelatedTask&gt; value) {
<span class="nc" id="L1243">          _relatedTasks = value;</span>
<span class="nc" id="L1244">        }</span>

        /**
         * Add a new {@link RelatedTask} item to the underlying collection.
         * @param item the item to add
         * @return {@code true}
         */
        public boolean addRelatedTask(RelatedTask item) {
<span class="nc" id="L1252">          RelatedTask value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">          if (_relatedTasks == null) {</span>
<span class="nc" id="L1254">            _relatedTasks = new LinkedList&lt;&gt;();</span>
          }
<span class="nc" id="L1256">          return _relatedTasks.add(value);</span>
        }

        /**
         * Remove the first matching {@link RelatedTask} item from the underlying collection.
         * @param item the item to remove
         * @return {@code true} if the item was removed or {@code false} otherwise
         */
        public boolean removeRelatedTask(RelatedTask item) {
<span class="nc" id="L1265">          RelatedTask value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L1266" title="All 4 branches missed.">          return _relatedTasks != null &amp;&amp; _relatedTasks.remove(value);</span>
        }

        public MarkupMultiline getRemarks() {
<span class="nc" id="L1270">          return _remarks;</span>
        }

        public void setRemarks(MarkupMultiline value) {
<span class="nc" id="L1274">          _remarks = value;</span>
<span class="nc" id="L1275">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L1279">          return new ReflectionToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).toString();</span>
        }
      }
    }
  }

  /**
   * Relates the finding to a set of referenced observations that were used to determine the finding.
   */
  @MetaschemaAssembly(
      formalName = &quot;Related Observation&quot;,
      description = &quot;Relates the finding to a set of referenced observations that were used to determine the finding.&quot;,
      name = &quot;related-observation&quot;,
      moduleClass = OscalAssessmentCommonModule.class
  )
  public static class RelatedObservation implements IBoundObject {
    private final IMetaschemaData __metaschemaData;

    /**
     * &quot;A &lt;a href=\&quot;https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented\&quot;&gt;machine-oriented&lt;/a&gt; identifier reference to an observation defined in the list of observations.&quot;
     */
    @BoundFlag(
        formalName = &quot;Observation Universally Unique Identifier Reference&quot;,
        description = &quot;A [machine-oriented](https://pages.nist.gov/OSCAL/concepts/identifier-use/#machine-oriented) identifier reference to an observation defined in the list of observations.&quot;,
        name = &quot;observation-uuid&quot;,
        required = true,
        typeAdapter = UuidAdapter.class
    )
    private UUID _observationUuid;

    public RelatedObservation() {
<span class="nc" id="L1310">      this(null);</span>
<span class="nc" id="L1311">    }</span>

<span class="nc" id="L1313">    public RelatedObservation(IMetaschemaData data) {</span>
<span class="nc" id="L1314">      this.__metaschemaData = data;</span>
<span class="nc" id="L1315">    }</span>

    @Override
    public IMetaschemaData getMetaschemaData() {
<span class="nc" id="L1319">      return __metaschemaData;</span>
    }

    public UUID getObservationUuid() {
<span class="nc" id="L1323">      return _observationUuid;</span>
    }

    public void setObservationUuid(UUID value) {
<span class="nc" id="L1327">      _observationUuid = value;</span>
<span class="nc" id="L1328">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L1332">      return new ReflectionToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).toString();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>